# option show.error.messages works as expected

    Code
      brew("error.brew", envir = new.env(), extendedErrorReport = TRUE)
    Output
      Error Test
    Message <simpleMessage>
      STACK DEPTH AE: 52
      Call stack at error:
      	testthat::test_file("~/src/rpackage/brew/tests/test-error.R")
      	test_files(test_dir = dirname(path), test_package = package,     test_paths = basename(path), reporter = reporter, ...)
      	test_files(test_dir = test_dir, test_package = test_package,     test_paths = test_paths, load_helpers = load_helpers, reporter = reporter,     env = env, stop_on_failure = stop_on_failure, stop_on_warning = stop_on_warning,     wrap = wrap, load_package = load_package)
      	with_reporter(reporters$multi, lapply(test_paths, test_one_file,     env = env, wrap = wrap))
      	tryCatch(code, testthat_abort_reporter = function(cnd) {    cat(conditionMessage(cnd), "\n")    NULL})
      	tryCatchList(expr, classes, parentenv, handlers)
      	tryCatchOne(expr, names, parentenv, handlers[[1L]])
      	doTryCatch(return(expr), name, parentenv, handler)
      	lapply(test_paths, test_one_file, env = env, wrap = wrap)
      	FUN(X[[i]], ...)
      	source_file(path, child_env(env), wrap = wrap)
      	test_code(NULL, exprs, env)
      	tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })
      	tryCatchList(expr, classes, parentenv, handlers)
      	tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])
      	doTryCatch(return(expr), name, parentenv, handler)
      	tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
      	tryCatchOne(expr, names, parentenv, handlers[[1L]])
      	doTryCatch(return(expr), name, parentenv, handler)
      	withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)
      	eval(code, test_env)
      	eval(code, test_env)
      	test_that("option show.error.messages works as expected", {    local_edition(3)    options(show.error.messages = TRUE)    expect_snapshot(brew("error.brew", envir = new.env(), extendedErrorReport = TRUE),         variant = "semTrueExt")    expect_snapshot(brew("error.brew", envir = new.env(), extendedErrorReport = FALSE),         variant = "semTrueNoExt")    options(show.error.messages = FALSE)    expect_snapshot(brew("error.brew", envir = new.env(), extendedErrorReport = TRUE),         variant = "semFalseExt")    expect_snapshot(brew("error.brew", envir = new.env(), extendedErrorReport = FALSE),         variant = "semFalseNoExt")    options(show.error.messages = TRUE)})
      	test_code(desc, code, env = parent.frame(), reporter = reporter)
      	tryCatch(withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error), error = handle_fatal,     skip = function(e) {    })
      	tryCatchList(expr, classes, parentenv, handlers)
      	tryCatchOne(tryCatchList(expr, names[-nh], parentenv, handlers[-nh]),     names[nh], parentenv, handlers[[nh]])
      	doTryCatch(return(expr), name, parentenv, handler)
      	tryCatchList(expr, names[-nh], parentenv, handlers[-nh])
      	tryCatchOne(expr, names, parentenv, handlers[[1L]])
      	doTryCatch(return(expr), name, parentenv, handler)
      	withCallingHandlers({    eval(code, test_env)    if (!handled && !is.null(test)) {        skip_empty()    }}, expectation = handle_expectation, skip = handle_skip, warning = handle_warning,     message = handle_message, error = handle_error)
      	eval(code, test_env)
      	eval(code, test_env)
      	expect_snapshot(brew("error.brew", envir = new.env(), extendedErrorReport = TRUE),     variant = "semTrueExt")
      	verify_exec(quo_get_expr(x), quo_get_env(x), replay)
      	evaluate::evaluate(source, envir = env, new_device = FALSE, output_handler = handler)
      	evaluate_call(expr, parsed$src[[i]], envir = envir, enclos = enclos,     debug = debug, last = i == length(out), use_try = stop_on_error !=         2L, keep_warning = keep_warning, keep_message = keep_message,     output_handler = output_handler, include_timing = include_timing)
      	timing_fn(handle(ev <- withCallingHandlers(withVisible(eval(expr,     envir, enclos)), warning = wHandler, error = eHandler, message = mHandler)))
      	handle(ev <- withCallingHandlers(withVisible(eval(expr, envir,     enclos)), warning = wHandler, error = eHandler, message = mHandler))
      	try(f, silent = TRUE)
      	tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
      	tryCatchList(expr, classes, parentenv, handlers)
      	tryCatchOne(expr, names, parentenv, handlers[[1L]])
      	doTryCatch(return(expr), name, parentenv, handler)
      	withCallingHandlers(withVisible(eval(expr, envir, enclos)), warning = wHandler,     error = eHandler, message = mHandler)
      	withVisible(eval(expr, envir, enclos))
      	eval(expr, envir, enclos)
      	eval(expr, envir, enclos)
      	brew("error.brew", envir = new.env(), extendedErrorReport = TRUE)
      	 ...
      	fna()
      	fnb()
    Output
      Error in fnc() : could not find function "fnc"

